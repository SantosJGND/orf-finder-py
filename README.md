# orf-finder-py
Python script utilised for identifying open reading frames in a study of Calliactis polypus regeneration (Transcriptomic investigation of wound healing and regeneration in the cnidarian Calliactis polypus, Scientific Reports, doi: 10.1038/srep41458) (http://www.nature.com/articles/srep41458)

# Dependencies
This script was designed to work with Python versions 3.4 and 3.5, and utilises the in-built ‘re’ and ‘os’ packages, as well as the external ‘Biopython’ package (https://github.com/biopython/biopython.github.io/). This script was built and tested on the Windows 10 OS, though there should be no reason why it cannot run on any OS that Python is capable of running on.

# Description of script logic
This script was designed to be used by those unfamiliar with command line operations. Thus, the starting section of the script has text prompts which specify to the user what commands are required at each point, with checks in place to ensure the user inputs the correct values. The order of this is to...

1. Specify the name of the fasta file which contains the nucleotide sequences from which ORFs will be extracted.
2. Specify the output file name containing the extracted ORFs.
3. Specify the minimum ORF length you wish to consider. 
4. Specify the number of ORFs you wish to obtain which meet this length requirement.
5. Specify two stringency values which will determine the weighting with which we will consider ORFs with non-traditional (i.e., TTG, GTG, CTG) or no-codon (i.e., fragmented sequence) starts as opposed to traditional. 

Before delving into the specifics of how these stringencies (step 5) work, it should first be mentioned that this script works on the basis of identifying regions in-between stop codons. Thus, to this script, an ORF is any region uninterrupted by stop codons. Returning to the stringency values, these values have defaults which I recommend the script runs with, but if shorter peptides (such as those of 10-50AA length) which often have alternative starts are sought, then lowering the stringency of these default values manually is a valid option. No-codon starts are by default weighted against the most heavily, as the assumption with this is that the transcript being analysed is fragmentary and lacks its actual start site. This assumption should only be considered in the absence of any identifiable, putative ORFs with start codons within the sequence, hence the heavy weighting. The two stringency values together help to define the ‘best’ ORF identified in a sequence according to its overall length. As such, while an alternative start may render a longer ORF than an ATG start, the stringency value will weight this so that an alternative start will only be accepted if it increases ORF length by a large margin. As such, this script works solely on the basis of ORF length, attempting to provide the longest ORF with the most sensible start codon.

# File in- and output
This script will read in fasta-formatted ‘.fa’ or ‘.fasta’ files containing nucleotide sequences. The output will be a fasta-formatted ‘.fasta’ file containing protein translations of ORFs identified. The original sequence identifiers will be modified in this output to contain the ORF number as determined from this script. For example, if an original nucleotide sequence is titled ‘>contig1’, depending on the number of ORFs identified in this sequence, the output file will have entries titled ‘>contig1_ORF1’ and ‘>contig1_ORF2’, etc.

# Additional notes
As the writer of this script (Zachary K Stewart) is self-taught, this script is not written in a highly ‘professional’ manner, such as according to PEP8, which may reduce its readability, though it is still capable of performing its function well. The script should be relatively light on CPU and RAM usage, and thus should be suitable for use on all types of computers. Unless the CPU is very weak, this script should be capable of processing files with hundreds of thousands of sequences in time spans of less than 10 minutes (approximately), though depending on how small of a minimum ORF length you specify this time can vary to some degree. As this script regularly updates the user on the progress of the script, it can be roughly gauged how long the script should take to complete.

More complex ORF finders may often consider things such as GC content and the presence of Kozak consensus sequences among other features. While this script does not offer this, operating solely on the basis of ORF length, through personal testing I have found it to provide results which are more reliable than NCBI’s ORF Finder. Due to the ability to determine the strictness with which we consider alternative starts, the script is designed to be suitable for finding novel ORFs wherein assumptions of GC content and other sequence features may not hold. Additionally, as this script is capable of pulling many ORFs out of a sequence, it is also intended for performing analyses such as the one in this study, wherein multiple transcriptomes had potential ORFs extracted and compared via BLAST to identify conserved regions. Subsequently, as mentioned, this script is designed primarily with novel ORF identification in mind. If you intend to use this for yourself, you may want to consider what your goals are, as this script is not necessarily designed to find the most biologically valid start codon of conserved genes which typically demonstrate certain sequence features (although it tries). If you do find this script useful in any studies you perform, I’d appreciate if you cite the publication this script is associated with, and feel free to contact me if you have any questions.
